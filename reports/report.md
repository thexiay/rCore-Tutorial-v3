* 协作式调度与抢占式调度的区别是什么？

答：协作式需要用户程序自己在合适的时机释放CPU的控制权，而抢占式调度是CPU自己控制何时给各个用户程序CPU控制权

√

* 中断、异常和系统调用有何异同之处？

答：
中断：操作系统硬件层或软件层面主动暂时中断程序的运行，是一部的，与CPU整张做什么没什么关系
异常：程序触发了不符合预期的行为
系统调用：程序主动调用操作系统的能力
相同之处：都是trap的一种，都会让高特权级进行处理

* RISC-V支持哪些中断/异常？
 
答：详见risc-v的操作手册：https://five-embeddev.com/quickref/interrupts.html

* 如何判断进入操作系统内核的起因是由于中断还是异常？

答：根据寄存器中scause的信息

** 在 RISC-V 中断机制中，PLIC 和 CLINT 各起到了什么作用？

答：是额外的中断控制器，可以捕获到机器发出的中断信号，然后发送给CPU和兴，区别在于PLIC是外设级别的，CLINT是集成在CPU一起的

正确答案：
CLINT 处理时钟中断 (MTI) 和核间的软件中断 (MSI)；PLIC 处理外部来源的中断 (MEI)。
PLIC 的规范文档： https://github.com/riscv/riscv-plic-spec

** 基于RISC-V 的操作系统支持中断嵌套？请给出进一步的解释说明。

答：？？？

正确答案：
RISC-V原生不支持中断嵌套。(在S态的内核中)只有 sstatus 的 SIE 位为 1 时，才会开启中断，再由 sie 寄存器控制哪些中断可以触发。触发中断时，sstatus.SPIE 置为 sstatus.SIE，而 sstatus.SIE 置为0；当执行 sret 时，sstatus.SIE置为 sstatus.SPIE，而 sstatus.SPIE 置为1。这意味着触发中断时，因为 sstatus.SIE 为0，所以无法再次触发中断。

** 本章提出的任务的概念与前面提到的进程的概念之间有何区别与联系？

答：这里的任务是进程的一部分。当前都是单任务进程，所以可以简单理解为任务就是进程的CPU实现的载体

正确答案：
联系：任务和进程都有自己独立的栈、上下文信息，任务是进程的“原始版本”，在第五章会将目前的用户程序从任务升级为进程。
区别：任务之间没有地址空间隔离，实际上是能相互访问到的；进程之间有地址空间隔离，一个进程无法访问到另一个进程的地址。

* 简单描述一下任务的地址空间中有哪些类型的数据和代码。

任务的地址空间有两部分，一部分是ELF产生的代码数据，另一部分是运行时分配的堆栈数据，当然目前的程序中还没有堆，只有用户栈数据。

正确答案：
.txxt：任务的代码段
.rodata：只读数据
.data：需要初始化的全局变量
.bss：未初始化或者初始化为0的全局变量


* 任务控制块保存哪些内容？

答：保留这几部分：
1.当前task的状态，RUNNING，Reday这些
2.任务的上下文信息，比如这个任务在被切走前和函数调用上下文（返回，参数，函数）


* 任务上下文切换需要保存与恢复哪些内容？

答：
保存：
1.sp寄存器：栈指针，表示当前运行的哪一个栈，是什么函数
2.s0~s11寄存器：被调用者保存函数参数
3.ra寄存器：函数返回地址，用于函数返回后执行下一个指令

* 特权级上下文和任务上下文有何异同？

答：trap context和task context的区别：
1.trap context保存的寄存器信息更多，task context保存的寄存器信息更少
2.它们都是保存在内核栈上的

正确答案
相同点:特权级上下文和任务上下文都保留了一组寄存器，都代表一个执行流
不同点：
1.特权级上下文切换可以发生在中断异常时，所以它不符合函数调用约定，需要保存所有通用寄存器。同时它又涉及特权级切换，所以还额外保留了一些 CSR，在切换时还会涉及更多的 CSR
2.任务上下文由内核手动触发，它包装在 os/src/task/switch.rs:__switch() 里，所以除了“返回函数与调用函数不同”之外，它符合函数调用约定，只需要保存通用寄存器中 callee 类型的寄存器。为了满足切换执行流时“返回函数与调用函数不同”的要求，它还额外保存 ra

* 上下文切换为什么需要用汇编语言实现？

答：因为要直接操作寄存器的值，高级语言不太好表示 ，这些行为被封装在编译器中了

* 有哪些可能的时机导致任务切换？

答：用户主动触发切换。

正确答案：
系统调用（包括进程结束执行）、时钟中断。

** 在设计任务控制块时，为何采用分离的内核栈和用户栈，而不用一个栈？

答：用户程序可以任意修改栈指针，将其指向任意位置，而内核在运行的时候总希望在某一个合法的栈上，所以需要用分开的两个栈。（其实只要用户知道了其内核栈的地址就可以修改，但是后面的章节会完全隔离开这两个内存区域，让其完全安全互不影响）
此外，利用后面的章节的知识可以保护内核和用户栈，让用户无法读写内核栈上的内容，保证安全。

*** 我们已经在 rCore 里实现了不少操作系统的基本功能：特权级、上下文切换、系统调用……为了让大家对相关代码更熟悉，我们来以另一个操作系统为例，比较一下功能的实现。看看换一段代码，你还认不认识操作系统。

阅读 Linux 源代码，特别是 riscv 架构相关的代码，回答以下问题：

Linux 正常运行的时候， stvec 指向哪个函数？是哪段代码设置的 stvec 的值？

Linux 里进行上下文切换的函数叫什么？（对应 rCore 的 __switch ）

Linux 里，和 rCore 中的 TrapContext 和 TaskContext 这两个类型大致对应的结构体叫什么？

Linux 在内核态运行的时候， tp 寄存器的值有什么含义？ sscratch 的值是什么？

Linux 在用户态运行的时候， sscratch 的值有什么含义？

Linux 在切换到内核态的时候，保存了和用户态程序相关的什么状态？

Linux 在内核态的时候，被打断的用户态程序的寄存器值存在哪里？在 C 代码里如何访问？

Linux 是如何根据系统调用编号找到对应的函数的？（对应 rCore 的 syscall::syscall() 函数的功能）

Linux 用户程序调用 ecall 的参数是怎么传给系统调用的实现的？系统调用的返回值是怎样返回给用户态的？

阅读代码的时候，可以重点关注一下如下几个文件，尤其是第一个 entry.S ，当然也可能会需要读到其它代码：

arch/riscv/kernel/entry.S （与 rCore 的 switch.S 对比）

arch/riscv/include/asm/current.h

arch/riscv/include/asm/processor.h

arch/riscv/include/asm/switch_to.h

arch/riscv/kernel/process.c

arch/riscv/kernel/syscall_table.c

arch/riscv/kernel/traps.c

include/linux/sched.h

此外，推荐使用 https://elixir.bootlin.com 阅读 Linux 源码，方便查找各个函数、类型、变量的定义及引用情况。

一些提示：

Linux 支持各种架构，查找架构相关的代码的时候，请认准文件名中的 arch/riscv 。

为了同时兼容 RV32 和 RV64，Linux 在汇编代码中用了几个宏定义。例如， REG_L 在 RV32 上是 lw ，而在 RV64 上是 ld 。同理， REG_S 在 RV32 上是 sw ，而在 RV64 上是 sd 。

如果看到 #ifdef CONFIG_ 相关的预处理指令，是 Linux 根据编译时的配置启用不同的代码。一般阅读代码时，要么比较容易判断出这些宏有没有被定义，要么其实无关紧要。比如，Linux 内核确实应该和 rCore 一样，是在 S-mode 运行的，所以 CONFIG_RISCV_M_MODE 应该是没有启用的。

汇编代码中可能会看到有些 TASK_ 和 PT_ 开头的常量，找不到定义。这些常量并没有直接写在源码里，而是自动生成的。

在汇编语言中需要用到的很多 struct 里偏移量的常量定义可以在 arch/riscv/kernel/asm-offsets.c 文件里找到。其中， OFFSET(NAME, struct_name, field) 指的是 NAME 的值定义为 field 这一项在 struct_name 结构体里，距离结构体开头的偏移量。最终这些代码会生成 asm/asm-offsets.h 供汇编代码使用。

#include <asm/unistd.h> 在 arch/riscv/include/uapi/asm/unistd.h ， #include <asm-generic/unistd.h> 在 include/uapi/asm-generic/unistd.h 。