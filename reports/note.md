# note

如果想要做到打印栈帧上的符号信息，可以查看std库中的backtrace.rs中关于栈帧的数据结构。

问答题
- 函数调用与系统调用有何区别？
1.函数调用走的是API 接口，而系统调用走的ABI接口  
2.函数调用都是在U特权级别运行，而系统调用会进入S特权级别，会更安全  
×
2对了  
3.函数调用可以随意指定调用目标；系统调用只能将控制流切换给调用操作系统内核给定的目标。  

- 为了方便操作系统处理，Ｍ态软件会将 S 态异常/中断委托给 S 态软件，请指出有哪些寄存器记录了委托信息，rustsbi 委托了哪些异常/中断？（也可以直接给出寄存器的值）
1.与特权切换相关的寄存器叫做CSR寄存器（control and status register）
2.具体的CSR寄存器中有
sstatus:trap发生前cpu的特权等级、
sepc:trap是一个异常的时候，trap发生之前执行的最后一条指令的地址
scause:描述trap的原因
stval:给出trap的附加信息
stvec:控制trap处理代码的入口地址
3.rustsbi委托了???
×
两个寄存器记录了委托信息： mideleg （中断委托）和 medeleg （异常委托）
参考 RustSBI 输出
```
[rustsbi] mideleg: ssoft, stimer, sext (0x222)
[rustsbi] medeleg: ima, ia, bkpt, la, sa, uecall, ipage, lpage, spage (0xb1ab)
```
可知委托了中断:  
1.ssoft : S-mode 软件中断
2.stimer : S-mode 时钟中断
3.sext : S-mode 外部中断

委托了异常：

1.ima : 指令未对齐  
2.ia : 取指访问异常  
3.bkpt : 断点  
4.la : 读异常  
5.sa : 写异常  
6.uecall : U-mode 系统调用  
7.ipage : 取指 page fault  
8.lpage : 读 page fault  
9.spage : 写 page fault  

- 如果操作系统以应用程序库的形式存在，应用程序可以通过哪些方式破坏操作系统？
1.非法的指令，比如关机
2.无效的地址访问
3.错误的数学计算，例如除0
×
1.缓冲区移除：覆盖写合法内存之外的部分，危及OS  
2.整数溢出:  
3.系统调用拦截:拦截读取敏感文件的系统调用并重定向到它们选择的文件，危及unikernel的安全  
4.资源耗尽  


-  编译器/操作系统/处理器如何合作，可采用哪些方法来保护操作系统不受应用程序的破坏？
1.编译器可以提前感知到一些非法的访问，在编译期检测一些错误结果
2.操作系统可以将应用程序和内核程序分开跑，在应用程序产生的中断/异常并不会影响到内核的运行
3.上述操作系统的隔离需要在硬件层面支持中断的捕获
×  
现代os做同有很多硬件机制保护，本文中讲到的特权级等级只是一种：  
1.特权级模式  
2.TEE可信执行环境  
3.ASLR地址空间布局随机化  

- RISC-V处理器的S态特权指令有哪些，其大致含义是什么，有啥作用？
1.本身属于高特权级的指令，例如`sret`指令
2.需要S级特权才能访问的寄存器，例如某个指令访问了CSR寄存器(读取或者写入)

- RISC-V处理器在用户态执行特权指令后的硬件层面的处理过程是什么？
硬件层面会产生中断，产生一个异常，该异常码为2，代表illegal instruction，然后切换到S级特权去处理该异常

×

正确答案:

CPU 执行完一条指令（如 ecall ）并准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成如下这些事情：  

sstatus 的 SPP 字段会被修改为 CPU 当前的特权级（U/S）。

sepc 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。

scause/stval 分别会被修改成这次 Trap 的原因以及相关的附加信息。

cpu 会跳转到 stvec 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。

CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 sret 来完成，这一条指令具体完成以下功能： * CPU 会将当前的特权级按照 sstatus 的 SPP 字段设置为 U 或者 S ； * CPU 会跳转到 sepc 寄存器指向的那条指令，然后继续执行。

- 操作系统在完成用户态<–>内核态双向切换中的一般处理过程是什么？

可以分为如下几个步骤:

1.主动发起(trap)或者被动发起(exception)

2.os保存用户程序执行切换时的上下文trapcontext(主要是寄存器的信息)，并将其保存到内核栈上

3.从os中捕获切换的入口开始执行

4.执行完成，开始restore tarpcontext

5.由于寄存器又恢复了，接着从用户的调用点继续执行


- 程序陷入内核的原因有中断、异常和陷入（系统调用），请问 riscv64 支持哪些中断 / 异常？如何判断进入内核是由于中断还是异常？描述陷入内核时的几个重要寄存器及其值。
中断:
1.时钟中断
2.断点
异常:
1.非法指令集
2.非法地址访问
3.地址没对齐
4.非法的页错误
陷入内核时最重要的几个寄存器是sstatus,sepc,scause,stval,stvec，上述已经介绍过了，这里就不介绍了

×

具体支持的异常和中断，详见RISC-V Instruction Set Manual Volume II: Privileged Architecture

根据寄存器scause的值去判断，1为中断，0表示异常

重要的寄存器对了


- 在哪些情况下会出现特权级切换：用户态–>内核态，以及内核态–>用户态？
用户态->内核态:
1.硬件中断
2.异常
3.系统调用，陷入
内核态->用户态
1.内核态处理逻辑结束

×

用户态->内核态：应用程序发起系统调用；应用程序出现异常；应用程序执行结束

内核态->用户态：启动应用程序需要初始化应用程序的上下文；应用程序发起的系统调用执行完毕


- Trap上下文的含义是啥？在本章的操作系统中，Trap上下文的具体内容是啥？如果不进行Trap上下文的保存于恢复，会出现什么情况？
trap上下文就是进入trap前用户程序的运行环境信息（函数调用链，参数等）。
具体内容就是通用寄存器和csr寄存器的信息。
如果不进行trap上下文的恢复，那么这种设计就是用户和内核使用同一个栈，但是这样用户很可能访问内核栈的信息，那如果设计不使用同一个栈，那么就会导致恢复时不知道继续从哪执行。

×

除了上述说的，还需要知道触发Trap之前CPU运行在哪个特权级